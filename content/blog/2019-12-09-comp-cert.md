+++
title = "CompCert: Formally Verified C Compiler"
extra.author = "Samuel Thomas & Daniel Weber"
extra.latex = true
extra.bio = """
  [Samuel Thomas](https://sgtpeacock.com) is a senior undergraduate applying to Graduate Schools for programming languages.
  [Daniel Weber]()
"""
+++

### Motivation / Introduction

### Semantic Preservation
In order for a compiler to be correct it needs to preserve the semantics of our source program. In this section, we formalize the notion of semantic correctness.

We assume that we have a formal semantics for our source and target languages that assigns *observable behaviors* to each program. We write $S \Downarrow B$ to mean $S$ executes with observable behavior $B$. An observable behavior includes things like whether the program terminates or not, various *going wrong* behaviors such as accessing an array out of bounds or invoking an undefined operation like dividing by zero. It also includes a trace of all external calls (system calls). However, it doesn't include the state of memory.

A possible definition of semantic preservation is, with $S$ being a source program and $C$ being a compiled program:

$\forall B, S \Downarrow B \Leftrightarrow C \Downarrow B$

This definition is too strict because a compiler might want to optimize away certain *going wrong* behaviors if, for example, they come from dead code. For this reason, we want to give the compiler a little bit more freedom and so the following definition is preferable:

$S \texttt{safe} \Rightarrow (\forall B, C \Downarrow B \Rightarrow S \Downarrow B)$

$S \texttt{safe}$ means that $S$ doesn't go wrong. This definition is saying that all of the observable behaviors of $C$ are a subset of the observable behaviors of $S$ and that if $S$ doesn't go wrong, then $C$ doesn't go wrong.

### Verification vs. Validation

### Structure of the Compiler

### Verification of the Register Allocation Pass

### Evaluation
