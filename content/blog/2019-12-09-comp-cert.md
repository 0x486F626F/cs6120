+++
title = "CompCert: Formally Verified C Compiler"
extra.author = "Samuel Thomas & Daniel Weber"
extra.latex = true
extra.bio = """
  [Samuel Thomas](https://sgtpeacock.com) is a senior undergraduate applying to Graduate Schools for programming languages.
  [Daniel Weber]()
"""
+++

### Motivation / Introduction

### Semantic Preservation
In order for a compiler to be correct it needs to preserve the semantics of our source program. In this section, we formalize the notion of semantic correctness.

We assume that we have a formal semantics for our source and target languages that assigns *observable behaviors* to each program. We write $S \Downarrow B$ to mean $S$ executes with observable behavior $B$. An observable behavior includes things like whether the program terminates or not, various *going wrong* behaviors such as accessing an array out of bounds or invoking an undefined operation like dividing by zero. It also includes a trace of all external calls (system calls). However, it doesn't include the state of memory.

A possible definition of semantic preservation is, with $S$ being a source program and $C$ being a compiled program:

$\forall B, S \Downarrow B \Leftrightarrow C \Downarrow B$

This definition is too strict because a compiler might want to optimize away certain *going wrong* behaviors if, for example, they come from dead code. For this reason, we want to give the compiler a little bit more freedom and so the following definition is preferable:

$S \texttt{safe} \Rightarrow (\forall B, C \Downarrow B \Rightarrow S \Downarrow B)$

$S \texttt{safe}$ means that $S$ doesn't go wrong. This definition is saying that all of the observable behaviors of $C$ are a subset of the observable behaviors of $S$ and that if $S$ doesn't go wrong, then $C$ doesn't go wrong.

#### Verification vs. Validation
The paper models a compiler as a total function from source programs to either `OK(C)`, a compiled program, or `Error`, the output that represents a compile-time error, signifying that the compiler was unable to produce code. There are two approaches for establishing that a compiler has the semantic preservation property discussed above: verifying the compiler directly using formal methods or verifying a *validator*, a boolean function accompanying the compiler that verifies the output of the compiler separately. The second approach is convenient because sometimes the validator is significantly simpler than the compiler. We'll see this approach used later for verifying part of the register pass.

### Structure of the Compiler

### Verification of the Register Allocation Pass

### Evaluation
